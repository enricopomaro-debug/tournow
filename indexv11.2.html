<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TourNow ‚Äî v16 (categorie raggruppate, UI semplificata)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin></script>
  <style>
    :root { --bg:#0b0b0c; --panel:#151518; --text:#f1f5f9; --muted:#94a3b8; --accent:#22d3ee; --border:#2b2b33; }
    *{box-sizing:border-box}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Arial;background:#0b0b0c;color:#f1f5f9}
    header{padding:10px 16px;border-bottom:1px solid #23232a;display:flex;gap:12px;align-items:center;justify-content:space-between}
    header h1{font-size:18px;margin:0}
    .badge{padding:4px 8px;border:1px solid var(--border);border-radius:999px;font-size:12px;color:#94a3b8}
    .warn{font-size:12px;color:#cbd5e1;background:#101014;border:1px dashed #334155;border-radius:8px;padding:8px 10px;margin:8px 16px}
    .container{display:grid;grid-template-columns:460px 1fr;min-height:calc(100vh - 56px)}
    @media (max-width:900px){.container{grid-template-columns:1fr}}
    .panel{padding:16px;background:#151518;border-right:1px solid #23232a}
    .row{display:flex;gap:8px}.row>*{flex:1}
    .field{margin-bottom:12px}.label{display:block;font-size:12px;color:#94a3b8;margin-bottom:6px}
    .checkboxes{display:flex;flex-direction:column;gap:8px}
    .chip{display:inline-flex;align-items:center;gap:8px;padding:8px 10px;border:1px solid #2b2b33;border-radius:12px;background:#101014;user-select:none}
    .chip input{accent-color:#22d3ee}
    input[type="number"],input[type="text"],select{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #2b2b33;background:#101014;color:#f1f5f9}
    button{width:100%;padding:12px 14px;border:none;border-radius:12px;background:linear-gradient(90deg,#06b6d4,#22d3ee);color:#001017;font-weight:700;cursor:pointer;margin-top:6px}
    button.ghost{background:#101014;color:#cfe9ef;border:1px solid #2b2b33}
    button:disabled{opacity:.5;cursor:not-allowed}
    #map{width:100%;height:calc(100vh - 56px)}
    .itinerary{margin-top:14px;border-top:1px solid #23232a;padding-top:12px}
    .step{padding:10px 12px;background:#101014;border:1px solid #2b2b33;border-radius:10px;margin-bottom:8px}
    .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    .legend .tag{font-size:11px;padding:4px 8px;background:#101014;border:1px solid #2b2b33;border-radius:999px;color:#cbd5e1}
    .ai-note{font-size:12px;color:#9fb9df;margin:6px 0 0}
    .title{font-weight:800;margin:4px 0 6px}
    .summary{font-size:13px;color:#cfe9ef;margin:0 0 8px}
    .pill{display:inline-block;font-size:11px;padding:2px 6px;border-radius:999px;border:1px solid #2b2b33;margin-left:6px}
    .hint{font-size:11px;color:#8aa1b6;margin-top:4px}
    .status{font-size:12px;color:#cfe9ef;background:#101014;border:1px solid #2b2b33;border-radius:10px;padding:8px 10px;margin-top:8px}
    .status strong{color:#22d3ee}
    .ac-wrap{position:relative}
    .ac-list{position:absolute;top:100%;left:0;right:0;background:#0f1219;border:1px solid #2b2b33;border-radius:10px;max-height:240px;overflow:auto;z-index:10}
    .ac-item{padding:10px 12px;border-bottom:1px dashed #1b2230;cursor:pointer}
    .ac-item:last-child{border-bottom:none}
    .ac-item:hover{background:#101826}
    .mode-row{display:flex;gap:8px;align-items:center}
    .radio{display:inline-flex;align-items:center;gap:8px;padding:8px 10px;border:1px solid #2b2b33;border-radius:12px;background:#101014;cursor:pointer;user-select:none}
    .radio input{accent-color:#10b981}
    .coords-pill{display:inline-flex;gap:6px;align-items:center;padding:6px 10px;border:1px solid #2b2b33;border-radius:999px;color:#cbd5e1;font-size:12px}
    .desc-img{width:100%;border-radius:8px;margin-top:6px}
    .desc-body{color:#cbd5e1;font-size:13px;margin-top:6px}
    .desc-oh{margin-top:4px;color:#cbd5e1;font-size:12px}

    /* Dropdown categorie raggruppate */
    .cat-group{
      border:1px solid #2b2b33;
      border-radius:10px;
      background:#101014;
      padding:6px 8px 4px;
    }
    .cat-group summary{
      cursor:pointer;
      list-style:none;
      display:flex;
      align-items:center;
      justify-content:space-between;
      font-size:13px;
      color:#cbd5e1;
    }
    .cat-group[open] summary{
      color:#f9fafb;
    }
    .cat-group summary::-webkit-details-marker{
      display:none;
    }
    .cat-summary-label{
      display:flex;
      align-items:center;
      gap:6px;
    }
    .cat-summary-chevron{
      font-size:11px;
      color:#64748b;
    }
    .cat-sublist{
      margin-top:6px;
      display:flex;
      flex-wrap:wrap;
      gap:6px;
    }
    .cat-sublist .chip{
      padding:6px 8px;
      border-radius:999px;
      font-size:12px;
    }
  </style>
</head>
<body>
<header>
  <h1>TourNow ‚Äî tour operator istantaneo</h1>
  <span class="badge">v16 ‚Ä¢ km realistici + categorie raggruppate + UI pulita</span>
</header>
<div class="warn">
  ‚ÑπÔ∏è <strong>Nota per uso locale:</strong> la geolocalizzazione funziona solo su <strong>HTTPS</strong> o <strong>localhost</strong> (non su <code>file://</code>). Avvia: <code>python -m http.server 5500</code> ‚Üí apri <code>http://localhost:5500</code>. Oppure usa <strong>partenza manuale</strong>.
</div>
<div class="container">
  <aside class="panel">
    <div class="field">
      <span class="label">Modalit√† partenza</span>
      <div class="mode-row">
        <label class="radio"><input type="radio" name="startMode" id="modeAuto" value="auto" checked/> Automatica (usa la mia posizione)</label>
        <label class="radio"><input type="radio" name="startMode" id="modeManual" value="manual"/> Manuale (imposta tu)</label>
      </div>
    </div>
    <div class="field" id="geoWrap">
      <button id="btnGeo" class="ghost">üìç Abilita posizione</button>
      <div id="geoStatus" class="status">Stato posizione: <strong>ignoto</strong></div>
    </div>
    <div id="manualWrap" style="display:none">
      <div class="field">
        <span class="label">Cerca un indirizzo o luogo</span>
        <div class="ac-wrap">
          <input id="manualAddress" type="text" placeholder="Es. Piazza San Marco, Venezia" autocomplete="off"/>
          <div id="acList" class="ac-list" style="display:none"></div>
        </div>
        <div class="hint">Oppure clicca sulla mappa per impostare il punto di partenza.</div>
      </div>
      <div class="field">
        <span class="label">Coordinate scelte</span>
        <div class="coords-pill" id="coordsPill">‚Äî</div>
      </div>
    </div>
    <div class="row">
      <div class="field">
        <span class="label">Tempo disponibile (min)</span>
        <input id="timeBudget" type="number" min="15" step="15" value="90"/>
      </div>
      <div class="field">
        <span class="label">Percorso</span>
        <select id="routeType">
          <option value="linear">Lineare</option>
          <option value="loop">Ad anello</option>
        </select>
      </div>
    </div>
    <div class="row">
      <div class="field">
        <span class="label">Modalit√† di spostamento</span>
        <select id="moveMode">
          <option value="foot">A piedi</option>
          <option value="bike">Bici</option>
        </select>
        <div class="hint" id="radiusHint"></div>
      </div>
      <div class="field">
        <span class="label">Raggio ricerca (km)</span>
        <input id="radiusKm" type="number" min="0.5" step="0.5" value="2.5"/>
      </div>
    </div>

    <!-- CATEGORIE RAGGRUPPATE -->
    <div class="field">
      <span class="label">Categorie da includere</span>
      <div class="checkboxes" id="interests"></div>
    </div>

    <div class="row">
      <div class="field">
        <span class="label">Schema blocchi</span>
        <select id="blockPreset">
          <option value="auto">Auto</option>
          <option value="culture,food,park">Cultura ‚Üí Cibo ‚Üí Parco</option>
          <option value="park,food,landmark">Parco ‚Üí Cibo ‚Üí Landmark</option>
          <option value="food,landmark,park">Cibo ‚Üí Landmark ‚Üí Parco</option>
          <option value="custom">Personalizzato</option>
        </select>
      </div>
      <div class="field">
        <span class="label">Blocchi personalizzati (CSV)</span>
        <input id="blockCustom" type="text" placeholder="es: culture,food,park"/>
      </div>
    </div>
    <div class="row">
      <div class="field">
        <span class="label">Max POI considerati</span>
        <input id="maxPois" type="number" min="5" max="35" step="5" value="35"/>
      </div>
      <div class="field">
        <span class="label">Max tappe per categoria</span>
        <input id="maxPerCat" type="number" min="1" step="1" value="3"/>
      </div>
    </div>

    <div class="field">
      <input id="safeBike" type="checkbox"/>
      <label for="safeBike">Bici sicura (beta)</label>
    </div>
    <div style="margin: 15px 0; padding: 12px; background-color: #fff3cd; border: 1px solid #ffecb5; color: #664d03; font-size: 15px; font-family: Arial, sans-serif; border-radius: 6px;">
‚ö†Ô∏è <strong>Attenzione:</strong> il percorso generato √® solo grafico. Aprire il link a Google Maps per ottenere il percorso effettivo.
</div>
<button id="btnFind">Trova POI & Genera itinerario</button>
    <button id="btnGMaps" style="margin-top:8px;background:linear-gradient(90deg,#22d3ee,#06b6d4)" disabled>
      Apri itinerario in Google Maps
    </button>
    <div class="itinerary">
      <div class="title">Itinerario</div>
      <div id="itinerary"></div>
      <div class="legend" id="legend"></div>
      <p class="ai-note" id="aiStatus"></p>
    </div>
    <div class="hint">
      Tip: in manuale puoi <strong>cercare un indirizzo</strong> o <strong>cliccare sulla mappa</strong> per impostare la partenza.<br> Dati: ¬© OpenStreetMap ‚Äî Overpass API ‚Ä¢ Routing: OSRM profilo ‚Äúfoot‚Äù.
    </div>
  </aside>
  <main id="map"></main>
</div>
<script>
  const OSRM_BASE = 'https://router.project-osrm.org';
  const BIKE_TIME_FACTOR = 0.35, BIKE_DWELL_FACTOR = 0.8, BIKE_RADIUS_BONUS_KM = 2;
  const WALK_SAFETY_MULTIPLIER = 1.9; // stima prudenziale a piedi
  const DIST_BACKTRACK_PENALTY = 0.40;
  const DIST_OUTWARD_BONUS     = 0.15;
  const COLORS = {}, toRad = d => d * Math.PI / 180;
  const $ = id => document.getElementById(id);
  const lonOf = o => { const v = o && (o.lon ?? o.lng); return typeof v === 'string' ? parseFloat(v) : v; };

  function haversineKm(a, b) {
    const R = 6371;
    const la1 = a.lat, la2 = b.lat;
    const lo1 = lonOf(a), lo2 = lonOf(b);
    const dLat = toRad(la2 - la1);
    const dLon = toRad(lo2 - lo1);
    const s = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(la1)) * Math.cos(toRad(la2)) * Math.sin(dLon / 2) ** 2;
    return 2 * R * Math.asin(Math.sqrt(s || 0));
  }

  // lunghezza di una polyline [ [lat,lng], ... ] in km
  function polylineLengthKm(latlngArray) {
    if (!latlngArray || latlngArray.length < 2) return 0;
    let d = 0;
    for (let i = 1; i < latlngArray.length; i++) {
      const prev = latlngArray[i - 1];
      const curr = latlngArray[i];
      d += haversineKm(
        { lat: prev[0], lon: prev[1] },
        { lat: curr[0], lon: curr[1] }
      );
    }
    return d;
  }

  function autoColor(i) {
    const hues = [188, 160, 40, 12, 320, 260, 90, 200, 22, 280, 140, 30];
    return `hsl(${hues[i % hues.length]} 90% 60%)`;
  }

  const CATEGORIES = [
    { id: "culture",  label: "Musei/Gallerie",        query: '["tourism"~"museum|gallery"]',                     dwell: 40 },
    { id: "historic", label: "Siti storici",          query: '["historic"]',                                     dwell: 25 },
    { id: "monument", label: "Monumenti/Statue",      query: '["historic"="monument"]',                          dwell: 15 },
    { id: "castle",   label: "Castelli/Forti",        query: '["historic"~"castle|fort"]',                       dwell: 35 },
    { id: "church",   label: "Luoghi di culto",       query: '["amenity"="place_of_worship"]',                  dwell: 20 },
    { id: "theatre",  label: "Teatri/Opera",          query: '["amenity"~"theatre|arts_centre"]',               dwell: 25 },

    { id: "landmark", label: "Landmark",              query: '["tourism"="attraction"]',                         dwell: 20 },
    { id: "viewpoint",label: "Punti panoramici",      query: '["tourism"="viewpoint"]',                          dwell: 15 },
    { id: "bridge",   label: "Ponti scenici",         query: '["man_made"="bridge"]',                            dwell: 10 },
    { id: "tower",    label: "Torri/Belvedere",       query: '["man_made"="tower"]',                             dwell: 15 },
    { id: "square",   label: "Piazze",                query: '["place"="square"]',                               dwell: 15 },
    { id: "fountain", label: "Fontane",               query: '["amenity"="fountain"]',                           dwell: 10 },
    { id: "streetart",label: "Street Art/Murales",    query: '["tourism"="artwork"]["artwork_type"~"mural|graffiti|street_art"]', dwell: 15 },

    { id: "park",     label: "Parchi/Giardini",       query: '["leisure"~"park|garden|common"]',                dwell: 30 },
    { id: "water",    label: "Laghetti/Sponde",       query: '["natural"~"water|bay"]',                          dwell: 20 },
    { id: "beach",    label: "Spiagge/Lidi",          query: '["natural"="beach"]',                              dwell: 30 },

    { id: "food",     label: "Ristoranti/Bar",        query: '["amenity"~"restaurant|cafe|fast_food|bar"]',      dwell: 25 },
    { id: "gelato",   label: "Gelaterie",             query: '["amenity"="ice_cream"]',                          dwell: 15 },
    { id: "bakery",   label: "Panifici/Pasticcerie",  query: '["shop"~"bakery|pastry"]',                         dwell: 15 },
    { id: "coffee",   label: "Caff√® specialty",       query: '["amenity"="cafe"]["coffee"!=""]',                 dwell: 20 },
    { id: "wine",     label: "Enoteche/Wine bar",     query: '["amenity"~"bar|pub"]["wine"!=""]',                dwell: 20 },
    { id: "market",   label: "Mercati locali",        query: '["amenity"~"marketplace|market"]',                 dwell: 20 },

    { id: "exhibit",  label: "Mostre/Esposizioni",    query: '["exhibition"="permanent"]',                       dwell: 25 },
    { id: "shopping", label: "Vie dello shopping",    query: '["shop"]["name"]',                                 dwell: 20 }
  ];

  // 6 MACROCATEGORIE con sottocategorie
  const CATEGORY_GROUPS = [
    {
      id: "grp_culture",
      label: "Cultura & Storia",
      cats: ["culture","historic","monument","castle","church","theatre","exhibit"]
    },
    {
      id: "grp_landmark",
      label: "Landmark & Panorami",
      cats: ["landmark","viewpoint","tower","bridge","square","streetart","fountain"]
    },
    {
      id: "grp_nature",
      label: "Natura & Relax",
      cats: ["park","water","beach"]
    },
    {
      id: "grp_food",
      label: "Food & Drink",
      cats: ["food","gelato","bakery","coffee","wine","market"]
    },
    {
      id: "grp_shopping",
      label: "Shopping & Lifestyle",
      cats: ["shopping"]
    },
    {
      id: "grp_other",
      label: "Altri POI",
      cats: [] // per eventuali future categorie extra
    }
  ];

  // preselezione di default
  const DEFAULT_SELECTED = new Set(["landmark","square","park","food","gelato"]);

  const interestsWrap = $('interests'),
        legendWrap   = $('legend');
  const radiusHint = $('radiusHint'), geoStatus = $('geoStatus'), btnGeo = $('btnGeo');
  const modeAuto = $('modeAuto'), modeManual = $('modeManual'), manualWrap = $('manualWrap');
  const manualAddress = $('manualAddress'), acList = $('acList'), coordsPill = $('coordsPill');
  const safeBike = $('safeBike');

  // colori + legenda
  CATEGORIES.forEach((c, i) => {
    COLORS[c.id] = autoColor(i);

    const tag = document.createElement('span');
    tag.className = 'tag';
    tag.style.borderColor = COLORS[c.id];
    tag.style.color = COLORS[c.id];
    tag.textContent = c.label;
    legendWrap.appendChild(tag);
  });

  // UI categorie raggruppate
  function buildGroupedCategoryUI() {
    interestsWrap.innerHTML = '';

    CATEGORY_GROUPS.forEach(group => {
      if (!group.cats.length) return;

      const details = document.createElement('details');
      details.className = 'cat-group';
      details.open = true;

      const summary = document.createElement('summary');
      const labelDiv = document.createElement('div');
      labelDiv.className = 'cat-summary-label';
      labelDiv.textContent = group.label;

      const chevron = document.createElement('span');
      chevron.className = 'cat-summary-chevron';
      chevron.textContent = '‚ñæ';

      summary.appendChild(labelDiv);
      summary.appendChild(chevron);
      details.appendChild(summary);

      const sublist = document.createElement('div');
      sublist.className = 'cat-sublist';

      group.cats.forEach(catId => {
        const cat = CATEGORIES.find(c => c.id === catId);
        if (!cat) return;
        const checked = DEFAULT_SELECTED.has(catId);
        const l = document.createElement('label');
        l.className = 'chip';
        l.innerHTML = `<input type="checkbox" value="${cat.id}" ${checked ? 'checked' : ''}/> ${cat.label}`;
        sublist.appendChild(l);
      });

      details.appendChild(sublist);
      interestsWrap.appendChild(details);
    });
  }

  buildGroupedCategoryUI();

  const readChecks = wrap => [...wrap.querySelectorAll('input[type=checkbox]')].filter(x => x.checked).map(x => x.value);
  const getSelectedCategoryIds = () => readChecks(interestsWrap);

  function detectCategory(tags) {
    if (tags.tourism === "museum" || tags.tourism === "gallery") return "culture";
    if (tags.historic === "monument") return "monument";
    if (tags.historic && /castle|fort/.test(tags.historic)) return "castle";
    if (tags.historic) return "historic";
    if (tags.amenity === "place_of_worship") return "church";
    if (tags.amenity && /theatre|arts_centre/.test(tags.amenity)) return "theatre";
    if (tags.tourism === "viewpoint") return "viewpoint";
    if (tags.man_made === "bridge") return "bridge";
    if (tags.man_made === "tower") return "tower";
    if (tags.place === "square") return "square";
    if (tags.amenity === "fountain") return "fountain";
    if (tags.tourism === "attraction") return "landmark";
    if (tags.leisure && /park|garden|common/.test(tags.leisure)) return "park";
    if (tags.natural === "beach") return "beach";
    if (tags.natural && /water|bay/.test(tags.natural)) return "water";
    if (tags.amenity && /restaurant|cafe|fast_food|bar/.test(tags.amenity)) return "food";
    if (tags.amenity === "ice_cream") return "gelato";
    if (tags.shop && /bakery|pastry/.test(tags.shop)) return "bakery";
    if (tags.amenity === "cafe" && tags.coffee) return "coffee";
    if ((tags.amenity === "bar" || tags.amenity === "pub") && tags.wine) return "wine";
    if (tags.amenity && /marketplace|market/.test(tags.amenity)) return "market";
    if (tags.tourism === "artwork" && /mural|graffiti|street_art/.test((tags.artwork_type || ""))) return "streetart";
    if (tags.exhibition === "permanent") return "exhibit";
    if (tags.shop && tags.name) return "shopping";
    return "landmark";
  }

  // --- WIKI HELPERS ---
  const WIKI_REST = 'https://{lang}.wikipedia.org/api/rest_v1';
  const WD_API = 'https://www.wikidata.org/w/api.php';
  const wikiCache = new Map();
  function pickLang() { return 'it'; }
  function parseWikipediaTag(tagVal) {
    if (!tagVal) return null;
    const idx = tagVal.indexOf(':');
    if (idx < 0) return null;
    const lang = tagVal.slice(0, idx);
    const title = tagVal.slice(idx + 1);
    if (!lang || !title) return null;
    return { lang, title };
  }
  async function getWikiFromWikipediaTag(tagVal) {
    if (wikiCache.has(tagVal)) return wikiCache.get(tagVal);
    const info = parseWikipediaTag(tagVal);
    if (!info) return null;
    const url = `${WIKI_REST.replace('{lang}', info.lang)}/page/summary/${encodeURIComponent(info.title)}`;
    try {
      const r = await fetch(url);
      if (!r.ok) return null;
      const js = await r.json();
      const out = { title: js.title, descHtml: js.extract_html || '', thumb: js.thumbnail?.source || null, url: js.content_urls?.desktop?.page || null };
      wikiCache.set(tagVal, out);
      return out;
    } catch { return null; }
  }
  async function getWikiFromWikidataId(qid) {
    if (wikiCache.has(qid)) return wikiCache.get(qid);
    try {
      const api = `${WD_API}?origin=*&action=wbgetentities&ids=${encodeURIComponent(qid)}&format=json&props=labels|sitelinks|claims`;
      const r = await fetch(api);
      if (!r.ok) return null;
      const js = await r.json();
      const ent = js.entities?.[qid];
      if (!ent) return null;
      const lang = pickLang();
      const label = ent.labels?.[lang]?.value || ent.labels?.en?.value || null;
      const sitelink = ent.sitelinks?.itwiki?.title || ent.sitelinks?.enwiki?.title || null;
      let wiki = null;
      if (sitelink) {
        const langForLink = ent.sitelinks?.itwiki ? 'it' : 'en';
        const url = `${WIKI_REST.replace('{lang}', langForLink)}/page/summary/${encodeURIComponent(sitelink)}`;
        try {
          const s = await fetch(url);
          if (s.ok) {
            const js2 = await s.json();
            wiki = { title: js2.title || label, descHtml: js2.extract_html || '', thumb: js2.thumbnail?.source || null, url: js2.content_urls?.desktop?.page || null };
          }
        } catch { }
      }
      if (!wiki?.thumb) {
        const p18 = ent.claims?.P18?.[0]?.mainsnak?.datavalue?.value;
        if (p18) {
          const commons = `https://commons.wikimedia.org/wiki/Special:FilePath/${encodeURIComponent(p18)}?width=640`;
          wiki = wiki || { title: label, descHtml: '', url: null };
          wiki.thumb = commons;
        }
      }
      const out = wiki || { title: label, descHtml: '', thumb: null, url: null };
      wikiCache.set(qid, out);
      return out;
    } catch { return null; }
  }
  async function getWikiBySearchTitle(name, lang = 'it') {
    if (!name) return null;
    const cacheKey = `search:${lang}:${name}`;
    if (wikiCache.has(cacheKey)) return wikiCache.get(cacheKey);
    try {
      const searchUrl = `https://${lang}.wikipedia.org/api/rest_v1/search/title?q=${encodeURIComponent(name)}&limit=1`;
      const r = await fetch(searchUrl);
      if (!r.ok) return null;
      const js = await r.json();
      const hit = js?.pages?.[0];
      if (!hit || !hit.key) return null;
      const sumUrl = `https://${lang}.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(hit.key)}`;
      const s = await fetch(sumUrl);
      if (!s.ok) return null;
      const sum = await s.json();
      const out = { title: sum.title, descHtml: sum.extract_html || '', thumb: sum.thumbnail?.source || null, url: sum.content_urls?.desktop?.page || null };
      wikiCache.set(cacheKey, out);
      return out;
    } catch { return null; }
  }
  function formatAddress(tags = {}) {
    const parts = [];
    if (tags['addr:street']) {
      parts.push(tags['addr:street'] + (tags['addr:housenumber'] ? (' ' + tags['addr:housenumber']) : ''));
    }
    if (tags['addr:city']) parts.push(tags['addr:city']);
    if (tags['addr:postcode']) parts.push(tags['addr:postcode']);
    return parts.join(', ');
  }
  let ohLibLoaded = false;
  async function ensureOpeningHoursLib() {
    if (ohLibLoaded) return;
    await new Promise((res, rej) => {
      const s = document.createElement('script');
      s.src = 'https://unpkg.com/opening_hours@3.9.0/opening_hours.js';
      s.onload = () => res();
      s.onerror = () => rej(new Error('opening_hours load error'));
      document.head.appendChild(s);
    });
    ohLibLoaded = true;
  }
  async function renderOpeningHoursStatus(tags) {
    if (!tags || !tags.opening_hours) return '';
    try {
      await ensureOpeningHoursLib();
      const oh = new opening_hours(tags.opening_hours);
      const now = new Date();
      const isOpen = oh.getState(now);
      let status = isOpen ? 'Aperto ora' : 'Chiuso';
      const next = oh.getNextChange(now);
      if (next) {
        const hh = next.getHours().toString().padStart(2, '0');
        const mm = next.getMinutes().toString().padStart(2, '0');
        status += isOpen ? ` ‚Ä¢ chiude alle ${hh}:${mm}` : ` ‚Ä¢ apre alle ${hh}:${mm}`;
      }
      return `<div class="desc-oh">${status}</div>`;
    } catch { return ''; }
  }
  function shortCategoryLabel(cat) { const c = CATEGORIES.find(x => x.id === cat); return c ? c.label : cat; }
  function buildBasicPopupHTML(p) {
    const color = COLORS[p.category] || '#22d3ee';
    const cat = shortCategoryLabel(p.category);
    const addr = formatAddress(p.tags || {});
    const addrLine = addr ? `<div style="font-size:12px;color:#9fb9c9;margin:4px 0;">${addr}</div>` : '';
    const base = `
      <div style="min-width:260px">
        <div style="font-weight:700">${p.name}</div>
        <div class="pill" style="border-color:${color};color:${color};display:inline-block;margin:6px 0;">${cat}</div>
        ${addrLine}
        <div class="desc" data-desc="1" style="color:#cbd5e1;font-size:13px;">Caricamento info‚Ä¶</div>
        <div class="oh" data-oh="1"></div>
      </div>`;
    return base;
  }
  async function enrichContentFor(p) {
    let html = '';
    try {
      if (p.tags?.wikipedia) {
        const w = await getWikiFromWikipediaTag(p.tags.wikipedia);
        if (w) html = (w.thumb ? `<img class="desc-img" src="${w.thumb}"/>` : '') + (w.descHtml || '') + (w.url ? `<div style="margin-top:4px"><a href="${w.url}" target="_blank" rel="noopener">Wikipedia</a></div>` : '');
      } else if (p.tags?.wikidata) {
        const w = await getWikiFromWikidataId(p.tags.wikidata);
        if (w) html = (w.thumb ? `<img class="desc-img" src="${w.thumb}"/>` : '') + (w.descHtml || '') + (w.url ? `<div style="margin-top:4px"><a href="${w.url}" target="_blank" rel="noopener">Approfondisci</a></div>` : '');
      } else {
        const w = await getWikiBySearchTitle(p.name, pickLang());
        if (w) html = (w.thumb ? `<img class="desc-img" src="${w.thumb}"/>` : '') + (w.descHtml || '') + (w.url ? `<div style="margin-top:4px"><a href="${w.url}" target="_blank" rel="noopener">Dettagli</a></div>` : '');
      }
    } catch { }
    if (!html) {
      const addr = formatAddress(p.tags || {});
      const parts = [];
      if (addr) parts.push(addr);
      if (p.tags?.start_date) parts.push(`Dal ${p.tags.start_date}`);
      if (p.tags?.cuisine) parts.push(`Cucina: ${p.tags.cuisine}`);
      if (parts.length) html = `<div class="desc-body">${parts.join(' ‚Ä¢ ')}</div>`;
      else html = `<div class="desc-body">Nessuna descrizione disponibile.</div>`;
    }
    const ohHtml = await renderOpeningHoursStatus(p.tags);
    return { html, ohHtml };
  }

  // Leaflet + layers
  const map = L.map('map', { zoomControl: true });
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '¬© OpenStreetMap' }).addTo(map);
  let userMarker = null, poiLayer = L.layerGroup().addTo(map), routeLayer = L.layerGroup().addTo(map);
  let lastOrigin = null;
  function setStatus(text) { geoStatus.innerHTML = 'Stato posizione: <strong>' + text + '</strong>'; }
  async function checkPermission() {
    if (!('permissions' in navigator)) return null;
    try {
      const s = await navigator.permissions.query({ name: 'geolocation' });
      setStatus(s.state);
      s.onchange = () => setStatus(s.state);
      return s.state;
    } catch (_) { return null; }
  }
  function setOrigin(lat, lng, from = 'manual') {
    lastOrigin = { lat, lng }; lastOrigin.lon = lng;
    map.setView([lat, lng], 15);
    if (userMarker) map.removeLayer(userMarker);
    userMarker = L.marker([lat, lng], { title: 'Partenza' }).addTo(map).bindPopup(from === 'geo' ? 'Tu sei qui' : 'Partenza impostata a mano');
    if (modeManual.checked) {
      try { localStorage.setItem('tn_manual_origin', JSON.stringify(lastOrigin)); } catch (_) { }
      coordsPill.textContent = `Lat ${lat.toFixed(5)}, Lng ${lng.toFixed(5)}`;
    }
  }
  async function requestGeolocation() {
    setStatus('richiesta‚Ä¶');
    return new Promise((resolve) => {
      if (!('geolocation' in navigator)) {
        setStatus('non supportata dal browser');
        resolve({ ok: false });
        return;
      }
      navigator.geolocation.getCurrentPosition(pos => {
        const { latitude, longitude } = pos.coords;
        setStatus('concessa');
        setOrigin(latitude, longitude, 'geo');
        resolve({ ok: true, lat: latitude, lng: longitude });
      }, err => {
        setStatus('negata o errore (' + err.code + ')');
        resolve({ ok: false });
      }, { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 });
    });
  }
  map.on('click', e => { if (modeManual.checked) { setOrigin(e.latlng.lat, e.latlng.lng, 'manual'); } });

  // Autocomplete Nominatim
  let acTimer = null;
  manualAddress?.addEventListener('input', () => {
    const q = manualAddress.value.trim();
    if (acTimer) clearTimeout(acTimer);
    if (!q) { acList.style.display = 'none'; acList.innerHTML = ''; return; }
    acTimer = setTimeout(() => searchNominatim(q), 250);
  });
  async function searchNominatim(q) {
    try {
      const url = new URL('https://nominatim.openstreetmap.org/search');
      url.searchParams.set('q', q);
      url.searchParams.set('format', 'json');
      url.searchParams.set('addressdetails', '1');
      url.searchParams.set('limit', '8');
      url.searchParams.set('countrycodes', 'it');
      const res = await fetch(url.toString(), { headers: { 'Accept': 'application/json' } });
      if (!res.ok) throw new Error('Geo API non disponibile');
      const data = await res.json();
      renderAC(data);
    } catch (err) {
      acList.innerHTML = `<div class="ac-item">Errore ricerca: ${err.message}</div>`;
      acList.style.display = 'block';
    }
  }
  function escapeHTML(s) { return (s || '').replace(/[&<>"]/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;' }[c] || c)); }
  function renderAC(results) {
    if (!results || !results.length) {
      acList.innerHTML = '<div class="ac-item">Nessun risultato</div>';
      acList.style.display = 'block';
      return;
    }
    acList.innerHTML = results.map(r => `<div class="ac-item" data-lat="${r.lat}" data-lon="${r.lon}">
        <div><strong>${escapeHTML(r.display_name.split(',')[0] || 'Luogo')}</strong></div>
        <div style="font-size:12px;color:#a9bfd4">${escapeHTML(r.display_name)}</div>
      </div>`).join('');
    acList.style.display = 'block';
  }
  acList?.addEventListener('click', (e) => {
    const item = e.target.closest('.ac-item');
    if (!item) return;
    const lat = parseFloat(item.dataset.lat), lon = parseFloat(item.dataset.lon);
    modeManual.checked = true; modeAuto.checked = false; manualWrap.style.display = 'block'; $('geoWrap').style.display = 'none';
    setOrigin(lat, lon, 'manual');
    acList.style.display = 'none'; acList.innerHTML = '';
    manualAddress.value = item.querySelector('div strong')?.textContent || manualAddress.value;
  });

  // Overpass
  function buildOverpassQuery(center, radiusM, selectedIds) {
    const parts = selectedIds.map(id => {
      const cat = CATEGORIES.find(c => c.id === id);
      return `
node${cat.query}(around:${radiusM},${center.lat},${lonOf(center)});
way${cat.query}(around:${radiusM},${center.lat},${lonOf(center)});
relation${cat.query}(around:${radiusM},${center.lat},${lonOf(center)});`.trim();
    }).join('\n');
    return `[out:json][timeout:25];(${parts});out center 60;`;
  }
  async function fetchPOIs(center, selectedIds, radiusM) {
    const q = buildOverpassQuery(center, radiusM, selectedIds);
    const endpoints = [
      'https://overpass-api.de/api/interpreter',
      'https://overpass.kumi.systems/api/interpreter'
    ];
    for (const ep of endpoints) {
      try {
        const resp = await fetch(ep, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body: new URLSearchParams({ data: q }) });
        if (!resp.ok) throw new Error('http_' + resp.status);
        const js = await resp.json();
        const items = (js.elements || []).map(e => {
          const lat = e.lat || (e.center && e.center.lat);
          const lon = e.lon || (e.center && e.center.lon);
          if (lat == null || lon == null) return null;
          const tags = e.tags || {};
          const name = tags.name || tags['name:it'] || tags['name:en'] || 'Punto d‚Äôinteresse';
          return { id: `${e.type}/${e.id}`, name, lat, lon, lng: lon, tags, category: detectCategory(tags) };
        }).filter(Boolean);
        const dedup = Object.values(items.reduce((acc, n) => { acc[n.id] = n; return acc; }, {}));
        if (dedup.length) return dedup;
      } catch (_) { }
    }
    const synth = Array.from({ length: 6 }).map((_, i) => {
      const ang = (i / 6) * 2 * Math.PI;
      const dKm = Math.min(radiusM / 1000, 1.2);
      const lat = center.lat + (dKm / 111) * Math.cos(ang);
      const lon = lonOf(center) + (dKm / (111 * Math.cos(center.lat * Math.PI / 180))) * Math.sin(ang);
      return { id: 'synth' + i, name: 'Punto interessante ' + (i + 1), lat, lon, lng: lon, tags: {}, category: (selectedIds[0] || 'landmark') };
    });
    return synth;
  }

  // OSRM helpers
  async function osrmTableFoot(coords) {
    const coordStr = coords.map(c => `${lonOf(c)},${c.lat}`).join(';');
    const url = `${OSRM_BASE}/table/v1/foot/${coordStr}?annotations=duration`;
    try {
      const r = await fetch(url);
      if (!r.ok) throw new Error('osrm_' + r.status);
      return await r.json();
    } catch (_) {
      const W_MPS = 0.9; // ~3.2 km/h
      const durations = coords.map(a => coords.map(b => {
        if (a === b) return 0;
        const km = haversineKm(a, b);
        return Math.round((km * 1000) / W_MPS);
      }));
      return { durations };
    }
  }
  async function osrmRouteFoot(a, b) {
    const url = `${OSRM_BASE}/route/v1/foot/${lonOf(a)},${a.lat};${lonOf(b)},${b.lat}?overview=full&geometries=geojson&steps=false`;
    try {
      const r = await fetch(url);
      if (!r.ok) throw new Error('osrm_' + r.status);
      return await r.json();
    } catch (_) {
      return null;
    }
  }
  async function osrmRouteBike(a, b) {
    const url = `${OSRM_BASE}/route/v1/bike/${lonOf(a)},${a.lat};${lonOf(b)},${b.lat}?overview=full&geometries=geojson&steps=false`;
    try {
      const r = await fetch(url);
      if (!r.ok) throw new Error('osrm_' + r.status);
      return await r.json();
    } catch (_) {
      return null;
    }
  }

  function dwellFor(cat) { const c = CATEGORIES.find(x => x.id === cat); return c ? c.dwell : 20; }

  // stima backup in linea d‚Äôaria (usata solo se OSRM non d√† geometrie)
  function estimateRouteDistanceKm(origin, steps, routeType) {
    if (!origin || !steps || !steps.length) return 0;
    let totalKm = 0;
    let prev = { lat: origin.lat, lon: lonOf(origin) };
    for (const s of steps) {
      const curr = { lat: s.lat, lon: s.lon };
      totalKm += haversineKm(prev, curr);
      prev = curr;
    }
    if (routeType === 'loop') {
      const back = { lat: origin.lat, lon: lonOf(origin) };
      totalKm += haversineKm(prev, back);
    }
    return totalKm;
  }

  function getBlockSequenceUI() {
    const selected = getSelectedCategoryIds();
    const preset = document.getElementById('blockPreset').value;
    if (preset === 'custom') {
      const raw = (document.getElementById('blockCustom').value || '').split(',').map(s => s.trim()).filter(Boolean);
      return raw.length ? raw : selected;
    }
    if (preset !== 'auto') { return preset.split(','); }
    const unique = arr => [...new Set(arr)];
    const restKnown = CATEGORIES.map(c => c.id).filter(c => !selected.includes(c));
    return unique([...selected, ...restKnown]);
  }

  async function planRouteReal(origin, pois, budgetMin, maxPerCat, blockSeq, routeType, moveMode) {
    const filtered = pois; // niente "evita": usiamo tutti i POI
    const maxPois = Math.min(35, Math.max(5, parseInt(document.getElementById('maxPois').value || '35', 10)));
    const sorted = [...filtered].sort((a, b) => {
      const da = haversineKm(origin, { lat: a.lat, lon: a.lon });
      const db = haversineKm(origin, { lat: b.lat, lon: b.lon });
      return da - db;
    }).slice(0, maxPois);
    const originForMatrix = { lat: origin.lat, lon: lonOf(origin) };
    const coords = [originForMatrix, ...sorted];
    const table = await osrmTableFoot(coords);
    const durations = table.durations.map(row =>
      row.map(sec => {
        if (sec == null) return null;
        let adjusted;
        if (moveMode === 'bike') {
          adjusted = Math.round(sec * BIKE_TIME_FACTOR);
        } else {
          adjusted = Math.round(sec * WALK_SAFETY_MULTIPLIER);
        }
        return Math.max(1, adjusted);
      })
    );
    const visit = [];
    const N = coords.length;
    const unvisited = new Set([...Array(N).keys()].slice(1));
    let current = 0;
    let timeUsedMin = 0;
    const perCatCount = {};
    let blockIdx = 0;
    const blockLen = Math.max(1, blockSeq.length);

    function wouldFit(idx, considerReturn) {
      const sec = durations[current][idx];
      if (sec == null) return null;
      const cand = coords[idx];
      const baseDwell = dwellFor(cand.category);
      const adjDwell = moveMode === 'bike'
        ? Math.ceil(baseDwell * BIKE_DWELL_FACTOR)
        : baseDwell;
      const travelMin = Math.ceil(sec / 60);
      const dwellMin = adjDwell;
      let retMin = 0;
      if (considerReturn && routeType === 'loop') {
        const backSec = durations[idx][0];
        if (backSec == null) return null;
        retMin = Math.ceil(backSec / 60);
      }
      const total = timeUsedMin + travelMin + dwellMin + retMin;
      return (total <= budgetMin)
        ? { sec, travelMin, dwellMin, retMin }
        : null;
    }

    while (unvisited.size) {
      let candidates = [...unvisited].filter(i =>
        (perCatCount[coords[i].category] || 0) < maxPerCat
      );

      const desired = blockSeq[blockIdx % blockLen];
      let bestIdx = -1;
      let bestScore = Infinity;
      let bestFit = null;

      function scoreCandidate(i, priorityBlock = false) {
        const fit = wouldFit(i, true);
        if (!fit) return null;
        const cand = coords[i];
        const secFromStartCandidate = durations[0][i];
        const secFromStartCurrent = durations[0][current];
        let radialDelta = 0;
        if (secFromStartCandidate != null && secFromStartCurrent != null) {
          radialDelta = secFromStartCandidate - secFromStartCurrent;
        }
        const progress = Math.min(1, timeUsedMin / Math.max(1, budgetMin));
        const backPenaltyBase = DIST_BACKTRACK_PENALTY * (1 - 0.5 * progress);
        let backPenaltySec = 0;
        let outwardBonusSec = 0;
        if (routeType === 'linear') {
          if (radialDelta < 0) {
            backPenaltySec = Math.abs(radialDelta) * backPenaltyBase;
          } else if (radialDelta > 0) {
            outwardBonusSec = radialDelta * DIST_OUTWARD_BONUS;
          }
        } else {
          if (radialDelta < 0) {
            backPenaltySec = Math.abs(radialDelta) * (backPenaltyBase * 0.5);
          }
        }
        const blockBonus = priorityBlock ? 120 : 0;
        const effectiveSec = Math.max(
          1,
          fit.sec + backPenaltySec - outwardBonusSec - blockBonus
        );
        return { fit, effectiveSec };
      }

      function trySelect(subset, priority = false) {
        for (const i of subset) {
          const res = scoreCandidate(i, priority);
          if (!res) continue;
          const { fit, effectiveSec } = res;
          if (effectiveSec < bestScore) {
            bestScore = effectiveSec;
            bestIdx = i;
            bestFit = fit;
          }
        }
      }

      const blockCandidates = candidates.filter(i => coords[i].category === desired);
      trySelect(blockCandidates, true);
      if (bestIdx < 0) {
        trySelect(candidates, false);
      }
      if (bestIdx < 0) break;

      const poi = coords[bestIdx];
      visit.push({
        ...poi,
        travelMin: bestFit.travelMin,
        dwellMin: bestFit.dwellMin
      });
      timeUsedMin += bestFit.travelMin + bestFit.dwellMin;
      perCatCount[poi.category] = (perCatCount[poi.category] || 0) + 1;
      unvisited.delete(bestIdx);
      current = bestIdx;
      blockIdx = (blockIdx + 1) % blockLen;
    }

    let returnMin = 0;
    if (routeType === 'loop' && visit.length) {
      const last = visit[visit.length - 1];
      const lastIdx = coords.indexOf(last);
      const backSec = durations[lastIdx][0];
      if (backSec != null) {
        returnMin = Math.ceil(backSec / 60);
      }
    }
    return { steps: visit, timeUsedMin, returnMin };
  }

  function renderPOIs(pois) {
    poiLayer.clearLayers();
    pois.forEach(p => {
      const m = L.circleMarker([p.lat, p.lon], { radius: 6, weight: 2, color: COLORS[p.category] || '#22d3ee', fillOpacity: 0.25 }).addTo(poiLayer);
      const baseHTML = buildBasicPopupHTML(p);
      m.bindPopup(baseHTML);
      m.on('popupopen', e => {
        (async () => {
          const container = e.popup.getElement();
          const enriched = await enrichContentFor(p);
          const descNode = container.querySelector('[data-desc]');
          const ohNode = container.querySelector('[data-oh]');
          if (descNode) descNode.innerHTML = enriched.html;
          if (ohNode) ohNode.innerHTML = enriched.ohHtml;
        })();
      });
    });
  }

  // disegna segmento a piedi e restituisce km del segmento
  async function osrmRouteFootDraw(prev, next, bounds, color) {
    let coords = null;
    try {
      const data = await osrmRouteFoot(prev, next);
      const route = data && data.routes && data.routes[0];
      if (route && route.geometry && Array.isArray(route.geometry.coordinates) && route.geometry.coordinates.length > 1) {
        coords = route.geometry.coordinates.map(([lon, lat]) => [lat, lon]);
      }
    } catch (_) { }
    if (!coords || !coords.length) {
      coords = [[prev.lat, lonOf(prev)], [next.lat, lonOf(next)]];
    }
    const segKm = polylineLengthKm(coords);
    L.polyline(coords, { color: color || '#22d3ee', weight: 5, opacity: 0.95 })
      .addTo(routeLayer)
      .bringToFront();
    coords.forEach(c => bounds.push(c));
    return segKm;
  }

  // disegna segmento bici e restituisce km del segmento
  async function osrmRouteBikeDraw(prev, next, bounds, color) {
    let coords = null;
    try {
      const data = await osrmRouteBike(prev, next);
      const route = data && data.routes && data.routes[0];
      if (route && route.geometry && Array.isArray(route.geometry.coordinates) && route.geometry.coordinates.length > 1) {
        coords = route.geometry.coordinates.map(([lon, lat]) => [lat, lon]);
      }
    } catch (_) { }
    if (!coords || !coords.length) {
      coords = [[prev.lat, lonOf(prev)], [next.lat, lonOf(next)]];
    }
    const segKm = polylineLengthKm(coords);
    L.polyline(coords, { color: color || '#22d3ee', weight: 5, opacity: 0.95 })
      .addTo(routeLayer)
      .bringToFront();
    coords.forEach(c => bounds.push(c));
    return segKm;
  }

  // usa OSRM per disegnare tutto il percorso e somma i km reali
  async function renderRouteWithOSRM(origin, steps, routeType) {
    routeLayer.clearLayers();
    if (!steps.length) return { totalKm: 0 };
    const originForDraw = { lat: origin.lat, lon: lonOf(origin) };
    let prev = originForDraw;
    const bounds = [[origin.lat, lonOf(origin)]];
    const moveModeVal = document.getElementById('moveMode').value;
    let totalKm = 0;

    for (const s of steps) {
      const segColor = COLORS[s.category] || '#22d3ee';
      let segKm = 0;
      if (moveModeVal === 'bike' && safeBike && safeBike.checked) {
        segKm = await osrmRouteBikeDraw(prev, s, bounds, segColor);
      } else {
        segKm = await osrmRouteFootDraw(prev, s, bounds, segColor);
      }
      totalKm += segKm;

      const marker = L.marker([s.lat, s.lon]).addTo(routeLayer);
      const baseHTML = `
        <div style="min-width:260px">
          <div style="font-weight:700">${s.name}</div>
          <div class="pill" style="border-color:${segColor};color:${segColor};display:inline-block;margin:6px 0;">
            ${shortCategoryLabel(s.category)}
          </div>
          <div style="font-size:12px;color:#9fb9c9;margin:4px 0;">
            Spost. ~${s.travelMin ?? '?'} min ‚Ä¢ Sosta ~${s.dwellMin ?? '?'} min
          </div>
          <div class="desc" data-desc="1" style="color:#cbd5e1;font-size:13px;">Caricamento info‚Ä¶</div>
          <div class="oh" data-oh="1"></div>
        </div>`;
      marker.bindPopup(baseHTML);
      marker.on('popupopen', e => {
        (async () => {
          const container = e.popup.getElement();
          const enriched = await enrichContentFor(s);
          const descNode = container.querySelector('[data-desc]');
          const ohNode = container.querySelector('[data-oh]');
          if (descNode) descNode.innerHTML = enriched.html;
          if (ohNode) ohNode.innerHTML = enriched.ohHtml;
        })();
      });
      prev = s;
    }

    if (routeType === 'loop' && steps.length) {
      let segKm = 0;
      if (moveModeVal === 'bike' && safeBike && safeBike.checked) {
        segKm = await osrmRouteBikeDraw(prev, originForDraw, bounds, '#5eead4');
      } else {
        segKm = await osrmRouteFootDraw(prev, originForDraw, bounds, '#5eead4');
      }
      totalKm += segKm;
    }

    map.fitBounds(bounds, { padding: [28, 28] });
    return { totalKm };
  }

  async function renderItinerary(steps, returnMin = 0, routeType = 'linear', originMode = 'auto', distanceKm = 0) {
    const box = document.getElementById('itinerary');
    if (!steps || !steps.length) {
      box.innerHTML = `<div class="step">Nessuna tappa rientra nel tempo impostato.</div>`;
      return;
    }
    box.innerHTML = '';
    let t = 0;
    for (let i = 0; i < steps.length; i++) {
      const s = steps[i];
      t += (s.travelMin || 0) + (s.dwellMin || 0);
      const color = COLORS[s.category] || '#22d3ee';
      const el = document.createElement('div');
      el.className = 'step';
      el.innerHTML = `
        <div><strong>${i + 1}. ${s.name}</strong>
          <span class="pill" style="border-color:${color};color:${color}">${shortCategoryLabel(s.category)}</span>
        </div>
        <div><small>‚Üí spostamento ~${s.travelMin ?? '?'} min, sosta ~${s.dwellMin ?? '?'} min</small></div>
        <div class="desc-body" data-desc="1">Caricamento info‚Ä¶</div>
        <div class="desc-oh" data-oh="1"></div>
      `;
      box.appendChild(el);
      (async () => {
        const enriched = await enrichContentFor(s);
        const descNode = el.querySelector('[data-desc]');
        const ohNode = el.querySelector('[data-oh]');
        if (descNode) descNode.innerHTML = enriched.html;
        if (ohNode) ohNode.innerHTML = enriched.ohHtml;
      })();
    }
    const tail = (routeType === 'loop' && returnMin > 0) ? `<div class="step" style="opacity:.85;">Rientro al punto di partenza: ~${returnMin} min</div>` : '';
    const originBadge = `<div class="step" style="opacity:.85;">Origine: <strong>${originMode === 'manual' ? 'Manuale' : 'Geolocalizzata'}</strong></div>`;
    const totalMinutes = t + (routeType === 'loop' ? returnMin : 0);
    const total = `<div class="step" style="opacity:.85;">
      <strong>Tempo stimato totale</strong>: ~${totalMinutes} min<br>
      <span style="font-size:12px;">Distanza stimata (traccia OSRM): ~${distanceKm.toFixed(1)} km</span>
    </div>`;
    const disclaimer = `<div class="step" style="opacity:.8;font-size:11px;line-height:1.4;">
      Stima prudenziale basata su routing OSRM (camminata lenta) + soste. <br>
      Controlla sempre il tempo reale su Google Maps prima di partire.
    </div>`;
    box.insertAdjacentHTML('afterbegin', originBadge);
    if (tail) box.insertAdjacentHTML('beforeend', tail);
    box.insertAdjacentHTML('beforeend', total);
    box.insertAdjacentHTML('beforeend', disclaimer);
  }

  const MAX_WAYPOINTS = 8;
  function buildGoogleMapsURL(origin, steps, routeType, moveMode) {
    if (!steps || !steps.length) return null;
    const originLon = lonOf(origin);
    const originStr = `${origin.lat},${originLon}`;
    let destinationStr = `${steps[steps.length - 1].lat},${steps[steps.length - 1].lon}`;
    let waypoints = steps.slice(0, steps.length - 1);
    if (routeType === 'loop') { destinationStr = originStr; waypoints = steps.slice(0); }
    let wp = waypoints.map(s => `${s.lat},${lonOf(s)}`);
    if (wp.length > MAX_WAYPOINTS) wp = wp.slice(0, MAX_WAYPOINTS);
    const travelmode = (moveMode === 'bike') ? 'bicycling' : 'walking';
    const params = new URLSearchParams({ api: '1', origin: originStr, destination: destinationStr, travelmode, hl: 'it' });
    if (wp.length) { params.set('waypoints', wp.join('|')); }
    return `https://www.google.com/maps/dir/?${params.toString()}`;
  }
  function openInGoogleMaps(url) { if (!url) return; window.open(url, '_blank', 'noopener,noreferrer'); }
  function getStartMode() { return modeManual.checked ? 'manual' : 'auto'; }

  async function getOriginForFlow() {
    try {
      const usp = new URLSearchParams(location.search);
      if (usp.has('start')) {
        const raw = usp.get('start'); const [la, lo] = (raw || '').split(',').map(parseFloat);
        if (isFinite(la) && isFinite(lo)) {
          modeManual.checked = true; modeAuto.checked = false; manualWrap.style.display = 'block'; $('geoWrap').style.display = 'none';
          setOrigin(la, lo, 'manual');
          return { lat: la, lng: lo };
        }
      }
    } catch (_) { }
    if (modeManual.checked) {
      if (lastOrigin) return lastOrigin;
      try {
        const saved = JSON.parse(localStorage.getItem('tn_manual_origin') || 'null');
        if (saved && isFinite(saved.lat) && isFinite(saved.lng)) {
          setOrigin(saved.lat, saved.lng, 'manual');
          return saved;
        }
      } catch (_) { }
      alert('Modalit√† manuale: imposta la partenza (cerca indirizzo o clicca sulla mappa).');
      throw new Error('Partenza manuale non impostata.');
    }
    const perm = await checkPermission();
    if (perm === 'denied') {
      modeManual.checked = true; modeAuto.checked = false; manualWrap.style.display = 'block'; $('geoWrap').style.display = 'none';
      alert('Permesso posizione negato: passa a modalit√† manuale (cerca o clicca sulla mappa).');
      throw new Error('Posizione negata.');
    }
    const res = await requestGeolocation();
    if (res.ok) return { lat: res.lat, lng: res.lng };
    modeManual.checked = true; modeAuto.checked = false; manualWrap.style.display = 'block'; $('geoWrap').style.display = 'none';
    throw new Error('Impossibile ottenere la posizione. Imposta manualmente.');
  }

  async function mainFlow() {
    const startMode = getStartMode();
    const origin = await getOriginForFlow();
    const selected = getSelectedCategoryIds();
    if (!selected.length) {
      alert('Seleziona almeno una sottocategoria in uno dei gruppi.');
      return;
    }
    const timeBudget = Math.max(15, parseInt(document.getElementById('timeBudget').value || '60', 10));
    const routeType = document.getElementById('routeType').value;
    const moveMode = document.getElementById('moveMode').value;
    const radiusKm = Math.max(0.5, parseFloat(document.getElementById('radiusKm').value || '2.5'));
    const maxPerCat = Math.max(1, parseInt(document.getElementById('maxPerCat').value || '3', 10));
    const blockSeq = getBlockSequenceUI();
    const effRadiusKm = radiusKm + (moveMode === 'bike' ? BIKE_RADIUS_BONUS_KM : 0);
    radiusHint.textContent = moveMode === 'bike'
      ? `Raggio effettivo in bici: ${effRadiusKm.toFixed(1)} km`
      : `Raggio effettivo a piedi: ${effRadiusKm.toFixed(1)} km`;

    const pois = await fetchPOIs(origin, selected, Math.round(effRadiusKm * 1000));
    const filtered = pois;
    renderPOIs(filtered);

    const plan = await planRouteReal(
      origin,
      filtered,
      timeBudget,
      maxPerCat,
      blockSeq,
      routeType,
      moveMode
    );

    const routeStats = await renderRouteWithOSRM(origin, plan.steps, routeType);
    let distanceKm = routeStats && typeof routeStats.totalKm === 'number'
      ? routeStats.totalKm
      : estimateRouteDistanceKm(origin, plan.steps, routeType);

    await renderItinerary(plan.steps, plan.returnMin, routeType, startMode, distanceKm);

    const gbtn = $('btnGMaps');
    const gurl = buildGoogleMapsURL(origin, plan.steps, routeType, moveMode);
    if (gurl) {
      gbtn.disabled = false;
      gbtn.onclick = () => openInGoogleMaps(gurl);
    } else {
      gbtn.disabled = true;
      gbtn.onclick = null;
    }
  }

  document.getElementById('btnFind').addEventListener('click', async () => {
    const btn = document.getElementById('btnFind');
    btn.disabled = true; btn.textContent = 'Elaboro‚Ä¶';
    try { await mainFlow(); } catch (e) { if (e && e.message) console.warn(e.message); }
    finally { btn.disabled = false; btn.textContent = 'Trova POI & Genera itinerario'; }
  });
  btnGeo.addEventListener('click', async () => {
    modeAuto.checked = true; modeManual.checked = false;
    manualWrap.style.display = 'none'; document.getElementById('geoWrap').style.display = 'block';
    await requestGeolocation();
    if (lastOrigin) map.setView([lastOrigin.lat, lonOf(lastOrigin)], 15);
  });
  modeAuto.addEventListener('change', () => {
    if (modeAuto.checked) {
      manualWrap.style.display = 'none';
      document.getElementById('geoWrap').style.display = 'block';
    }
  });
  modeManual.addEventListener('change', () => {
    if (modeManual.checked) {
      manualWrap.style.display = 'block';
      document.getElementById('geoWrap').style.display = 'none';
    }
  });

  (async () => {
    map.setView([45.07, 11.79], 12);
    const isFile = location.protocol === 'file:';
    if (isFile) {
      modeManual.checked = true; modeAuto.checked = false;
      manualWrap.style.display = 'block'; document.getElementById('geoWrap').style.display = 'none';
    }
    const usp = new URLSearchParams(location.search);
    if (usp.has('start')) {
      const [la, lo] = (usp.get('start') || '').split(',').map(parseFloat);
      if (isFinite(la) && isFinite(lo)) {
        modeManual.checked = true; modeAuto.checked = false;
        manualWrap.style.display = 'block'; document.getElementById('geoWrap').style.display = 'none';
        setOrigin(la, lo, 'manual');
      }
    } else if (!isFile) {
      if (modeAuto.checked) {
        await requestGeolocation();
      }
    }
    try {
      const saved = JSON.parse(localStorage.getItem('tn_manual_origin') || 'null');
      if (saved && isFinite(saved.lat) && isFinite(saved.lng)) {
        coordsPill.textContent = `Lat ${saved.lat.toFixed(5)}, Lng ${saved.lng.toFixed(5)}`;
      }
    } catch (_) { }
  })();
</script>
</body>
</html>

